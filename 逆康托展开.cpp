//逆康托展开

//例1 {1,2,3,4,5}的全排列，并且已经从小到大排序完毕
//(1)找出第96个数
//首先用96-1得到95
//用95去除4! 得到3余23
//用23去除3! 得到3余5
//用5去除2!得到2余1
//用1去除1!得到1余0
//有3个数比它小的数是4
//所以第一位是4
//有3个数比它小的数是4但4已经在之前出现过了所以是5（因为4在之前出现过了所以实际比5小的数是3个）
//有2个数比它小的数是3
//有1个数比它小的数是2
//最后一个数只能是1
//所以这个数是45321
//(2)找出第16个数
//首先用16-1得到15
//用15去除4!得到0余15
//用15去除3!得到2余3
//用3去除2!得到1余1
//用1去除1!得到1余0
//有0个数比它小的数是1
//有2个数比它小的数是3 但由于1已经在之前出现过了所以是4（因为1在之前出现过了所以实际比4小的数是2）
//有1个数比它小的数是2 但由于1已经在之前出现过了所以是3（因为1在之前出现过了所以实际比3小的数是1）
//有1个数比它小得数是2 但由于1，3，4已经在之前出现过了所以是5（因为1，3，4在之前出现过了所以实际比5小的数是1）
//最后一个数只能是2
//所以这个数是14352
//例题：
//描述
//现在有"abcdefghijkl”12个字符，将其按字典序排列，如果给出任意一种排列，我们能说出这个排列在所有的排列中是第几小的。但是现在我们给出它是第几小，需要
//你求出它所代表的序列.
//输入
//第一行有一个整数n（0<n<=10000）;
//随后有n行，每行是一个整数m，它代表着序列的第几小；
//输出
//输出一个序列，占一行，代表着第m小的序列。
//样例输入
//3
//1
//302715242
//260726926
//样例输出
//abcdefghijkl
//hgebkflacdji
//gfkedhjblcia
//代码如下：
/*
此题关键在于for循环中j的条件的变化
当第i个元素前有k个数比它小，则余数+k
但是可能前面有某个元素比i大，当i更新为余数+k后则小于i元素
则这个元素也需要更新+1.
当时知道错在这里，就是没法写出代码。
关键之处在于c++一次，条件更新一次。实时遍历。
*/
#include <stdio.h>
#include <string.h>
int a[12] = { 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 , 3628800 , 39916800 } ;
int vis[12] ;
int res[12] ;
int main()
{
int total , n ;
int i , j ;
scanf("%d", &total ) ;
while( total-- > 0 )
{
memset( vis , 0 , sizeof( vis ) ) ;
memset( res , 0 , sizeof( res ) ) ;
scanf("%d", &n ) ;
n -= 1 ;
for( i = 10 ; i >= 0 ; --i )
{
res[10 - i] = n / a[i] ;
n %= a[i] ;
}
for( i = 0 ; i < 11 ; ++i )
{
char c = res[i] + 'a' ;
for( j = 0 ; j <= c - 'a' ; ++j ) //关键
{
if( vis[j] )
c++ ;
}
vis[c - 'a'] = 1 ;
res[i] = c ;
}
for( i = 0 ; i < 12 ; ++i )
{
if( !vis[i] )
res[11] = 'a' + i ;
}
for( i = 0 ; i < 12 ; ++i )
printf("%c", res[i] ) ;
printf("\n") ;
}
return 0 ;
}
